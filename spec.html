<!DOCTYPE html>
<meta charset="utf-8">
<pre class="metadata">
title: x/freeSpacing flag for regular expressions
status: proposal
location: https://motiz88.github.io/proposal-regexp-freespacing-flag/
copyright: false
contributors: Moti Zilberman
</pre>
<script src="ecmarkup.js" defer></script>
<link rel="stylesheet" href="ecmarkup.css">
<style>
  hr {
    height: 0.25em;
    background: #ccc;
    border: 0;
    margin: 2em 0;
  }
</style>

<p>The algorithm listed in <a href="https://tc39.github.io/ecma262/#sec-regexpinitialize" title="Runtime Semantics: RegExpInitialize ( obj, pattern, flags )">21.2.3.2.2</a> is modified as follows.</p>

<emu-clause id="sec-regexpinitialize" aoid="RegExpInitialize">
<h1>Runtime Semantics: RegExpInitialize ( _obj_, _pattern_, _flags_ )</h1>
<p>When the abstract operation RegExpInitialize with arguments _obj_, _pattern_, and _flags_ is called, the following steps are taken:</p>
<emu-alg>
    1. If _pattern_ is *undefined*, let _P_ be the empty String.
    1. Else, let _P_ be ? ToString(_pattern_).
    1. If _flags_ is *undefined*, let _F_ be the empty String.
    1. Else, let _F_ be ? ToString(_flags_).
    1. If _F_ contains any code unit other than `"g"`, `"i"`, `"m"`, `"s"`, `"u"`, <ins>`"x"`</ins> or `"y"` or if it contains the same code unit more than once, throw a *SyntaxError* exception.
    1. <ins>If _F_ contains `"x"`, let _FreeSpacing_ be *false*; else let _BMP_ be *true*.</ins>
    1. If _F_ contains `"u"`, let _BMP_ be *false*; else let _BMP_ be *true*.
    1. If _BMP_ is *true*, then
      1. <ins>If _FreeSpacing_ is *true*, let _PatternGoalSymbol_ be |PatternX[~U, ~N]|.</ins>
      1. <ins>Else, let _PatternGoalSymbol_ be |Pattern[~U, ~N]|.</ins>
      1. Parse _P_ using the grammars in <emu-xref href="#sec-patterns"></emu-xref> and interpreting each of its 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is <del>|Pattern[~U, ~N]|</del><ins>given by _PatternGoalSymbol_</ins>. If the result of parsing contains a |GroupName|, reparse with the goal symbol |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError* exception if _P_ did not conform to the grammar, if any elements of _P_ were not matched by the parse, or if any Early Error conditions exist.
      1. Let _patternCharacters_ be a List whose elements are the code unit elements of _P_.
    1. Else,
      1. <ins>If _FreeSpacing_ is *true*, let _PatternGoalSymbol_ be |PatternX[+U, +N]|.</ins>
      1. <ins>Else, let _PatternGoalSymbol_ be |Pattern[+U, +N]|.</ins>
      1. Parse _P_ using the grammars in <emu-xref href="#sec-patterns"></emu-xref> and interpreting _P_ as UTF-16 encoded Unicode code points (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>). The goal symbol for the parse is <del>|Pattern[+U, +N]|</del><ins>given by _PatternGoalSymbol_</ins>. Throw a *SyntaxError* exception if _P_ did not conform to the grammar, if any elements of _P_ were not matched by the parse, or if any Early Error conditions exist.
      1. Let _patternCharacters_ be a List whose elements are the code points resulting from applying UTF-16 decoding to _P_'s sequence of elements.
    1. Set _obj_.[[OriginalSource]] to _P_.
    1. Set _obj_.[[OriginalFlags]] to _F_.
    1. Set _obj_.[[RegExpMatcher]] to the internal procedure that evaluates the above parse of _P_ by applying the semantics provided in <emu-xref href="#sec-pattern-semantics"></emu-xref> using _patternCharacters_ as the pattern's List of |SourceCharacter| values and _F_ as the flag parameters.
    1. Perform ? Set(_obj_, `"lastIndex"`, 0, *true*).
    1. Return _obj_.
</emu-alg>
</emu-clause>
<hr>

<p>The section <a href="https://tc39.github.io/ecma262/#sec-notation">21.2.2.1 Notation</a> is modified as follows.</p>
<emu-clause id="sec-notation">
  <h1>Notation</h1>
  <p>The descriptions below use the following variables:</p>
  <ul>
    <li>
      _Input_ is a List consisting of all of the characters, in order, of the String being matched by the regular expression pattern. Each character is either a code unit or a code point, depending upon the kind of pattern involved. The notation _Input_[_n_] means the _n_<sup>th</sup> character of _Input_, where _n_ can range between 0 (inclusive) and _InputLength_ (exclusive).
    </li>
    <li>
      _InputLength_ is the number of characters in _Input_.
    </li>
    <li>
      _NcapturingParens_ is the total number of left-capturing parentheses (i.e. the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes) in the pattern. A left-capturing parenthesis is any `(` pattern character that is matched by the `(` terminal of the <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> production.
    </li>
    <li>
      _DotAll_ is *true* if the RegExp object's [[OriginalFlags]] internal slot contains `"s"` and otherwise is *false*.
    </li>
    <li>
      <ins>_FreeSpacing_ is *true* if the RegExp object's [[OriginalFlags]] internal slot contains `"x"` and otherwise is *false*.</ins>
    </li>
    <li>
      _IgnoreCase_ is *true* if the RegExp object's [[OriginalFlags]] internal slot contains `"i"` and otherwise is *false*.
    </li>
    <li>
      _Multiline_ is *true* if the RegExp object's [[OriginalFlags]] internal slot contains `"m"` and otherwise is *false*.
    </li>
    <li>
      _Unicode_ is *true* if the RegExp object's [[OriginalFlags]] internal slot contains `"u"` and otherwise is *false*.
    </li>
  </ul>
  <emu-note type="editor">The _FreeSpacing_ variable has been added the sake of convenience; it will be removed from the proposal if it ultimately remains unused.</emu-note>
</emu-clause>
<hr>

<p>The algorithm listed in <a href="https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags" title="get RegExp.prototype.flags">21.2.5.4</a> is modified as follows.</p>

<emu-clause id="sec-get-regexp.prototype.flags">
  <h1>get RegExp.prototype.flags</h1>
  <p>`RegExp.prototype.flags` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
  <emu-alg>
    1. Let _R_ be the *this* value.
    1. If Type(_R_) is not Object, throw a *TypeError* exception.
    1. Let _result_ be the empty String.
    1. Let _global_ be ToBoolean(? Get(_R_, `"global"`)).
    1. If _global_ is *true*, append the code unit 0x0067 (LATIN SMALL LETTER G) as the last code unit of _result_.
    1. Let _ignoreCase_ be ToBoolean(? Get(_R_, `"ignoreCase"`)).
    1. If _ignoreCase_ is *true*, append the code unit 0x0069 (LATIN SMALL LETTER I) as the last code unit of _result_.
    1. Let _multiline_ be ToBoolean(? Get(_R_, `"multiline"`)).
    1. If _multiline_ is *true*, append the code unit 0x006D (LATIN SMALL LETTER M) as the last code unit of _result_.
    1. Let _dotAll_ be ToBoolean(? Get(_R_, `"dotAll"`)).
    1. If _dotAll_ is *true*, append the code unit 0x0073 (LATIN SMALL LETTER S) as the last code unit of _result_.
    1. Let _unicode_ be ToBoolean(? Get(_R_, `"unicode"`)).
    1. If _unicode_ is *true*, append the code unit 0x0075 (LATIN SMALL LETTER U) as the last code unit of _result_.
    1. <ins>Let _freeSpacing_ be ToBoolean(? Get(_R_, `"freeSpacing"`)).</ins>
    1. <ins>If _freeSpacing_ is *true*, append the code unit 0x0078 (LATIN SMALL LETTER X) as the last code unit of _result_.</ins>
    1. Let _sticky_ be ToBoolean(? Get(_R_, `"sticky"`)).
    1. If _sticky_ is *true*, append the code unit 0x0079 (LATIN SMALL LETTER Y) as the last code unit of _result_.
    1. Return _result_.
  </emu-alg>
</emu-clause>
<hr>

<p>The following new section is added before <a href="https://tc39.github.io/ecma262/#sec-get-regexp.prototype.global">21.2.5.5 get RegExp.prototype.global</a>.</p>

<emu-clause id="sec-get-regexp.prototype.freeSpacing">
  <h1>get RegExp.prototype.freeSpacing</h1>
  <p>`RegExp.prototype.freeSpacing` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
  <emu-alg>
    1. Let _R_ be the *this* value.
    1. If Type(_R_) is not Object, throw a *TypeError* exception.
    1. If _R_ does not have an [[OriginalFlags]] internal slot, then
      1. If SameValue(_R_, %RegExpPrototype%) is *true*, return *undefined*.
      1. Otherwise, throw a *TypeError* exception.
    1. Let _flags_ be _R_.[[OriginalFlags]].
    1. If _flags_ contains the code unit 0x0078 (LATIN SMALL LETTER X), return *true*.
    1. Return *false*.
  </emu-alg>
</emu-clause>
<hr>

<p>The syntax listed in <a href="https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals">11.8.5 Regular Expression Literals</a> is modified as follows.</p>
<emu-clause id="sec-literals-regular-expression-literals">
  <h1>Regular Expression Literals</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    RegularExpressionNonTerminator ::
      <del>SourceCharacter but not LineTerminator</del>
      <ins>SourceCharacter</ins>
  </emu-grammar>
</emu-clause>
<hr>

<p>The syntax listed in <a href="https://tc39.github.io/ecma262/#sec-patterns">21.2.1 Patterns</a> is modified as follows.</p>
<emu-clause id="sec-patterns">      
  <h1>Patterns</h1>
  
  <p>The `RegExp` constructor applies the following grammar to the input pattern String. An error occurs if the grammar cannot interpret the String as an expansion of |Pattern|.</p>
  
  <ins class="block">
    <p>
      Let |PatternX[U, N]| be a variant of the goal symbol |Pattern[U, N]| defined below, such that parsing with |PatternX| as the goal symbol skips over substrings matching the |RegExpWhitespaceOrComment| production, with the following restrictions:
    </p>
    <ol>
      <li>For a substring to be considered to match |RegExpWhitespaceOrComment|, its first element may not occur in a position immediately following a [no |RegExpWhitespaceOrComment| here] marker, or [no <i>space</i> here] for short.</li>
      <li>For a substring to be considered to match |RegExpWhitespaceOrComment|, it may not occur within a |DecimalDigits|, |CharacterClass|, |RegExpUnicodeEscapeSequence|, or |DecimalEscape| production. In other words, these particular productions (as well as their constituent nonterminals, recursively) are to be interpreted as if there were [no |RegExpWhitespaceOrComment| here] markers between each and every one of their symbols.</li>
      <li>If the phrase &ldquo;[lookahead &isin; _set_]&rdquo; or &ldquo;[lookahead = _terminal_]&rdquo; appears in the right-hand side of a production ending in a [no |RegExpWhitespaceOrComment| here] marker, the lookahead rule obtains the next input element without skipping any elements due to |RegExpWhitespaceOrComment|.</li>
    </ol>
  </ins>
  
  <h2>Syntax</h2>

  <emu-grammar type="definition">
    Pattern[U, N] ::
      Disjunction[?U, ?N]

    Disjunction[U, N] ::
      Alternative[?U, ?N]
      Alternative[?U, ?N] `|` Disjunction[?U, ?N]

    Alternative[U, N] ::
      [empty]
      Alternative[?U, ?N] Term[?U, ?N]

    Term[U, N] ::
      Assertion[?U, ?N]
      Atom[?U, ?N]
      Atom[?U, ?N] Quantifier

    Assertion[U, N] ::
      `^`
      `$`
      `\` <ins>[no space here]</ins> `b`
      `\` <ins>[no space here]</ins> `B`
      `(` `?` <ins>[no space here]</ins> `=` Disjunction[?U, ?N] `)`
      `(` `?` <ins>[no space here]</ins> `!` Disjunction[?U, ?N] `)`
      `(` `?` <ins>[no space here]</ins> `&lt;` <ins>[no space here]</ins> `=` Disjunction[?U, ?N] `)`
      `(` `?` <ins>[no space here]</ins> `&lt;` <ins>[no space here]</ins> `!` Disjunction[?U, ?N] `)`

    Quantifier ::
      QuantifierPrefix
      QuantifierPrefix `?`

    QuantifierPrefix ::
      `*`
      `+`
      `?`
      `{` DecimalDigits `}`
      `{` DecimalDigits `,` `}`
      `{` DecimalDigits `,` DecimalDigits `}`

    Atom[U, N] ::
      PatternCharacter
      `.`
      `\` <ins>[no space here]</ins> AtomEscape[?U, ?N]
      CharacterClass[?U]
      `(` GroupSpecifier[?U] Disjunction[?U, ?N] `)`
      `(` `?` <ins>[no space here]</ins> `:` Disjunction[?U, ?N] `)`

    SyntaxCharacter :: one of
      `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `|`

    PatternCharacter ::
      SourceCharacter but not SyntaxCharacter

    AtomEscape[U, N] ::
      DecimalEscape
      CharacterClassEscape[?U]
      CharacterEscape[?U]
      [+N] `k` GroupName[?U]

    CharacterEscape[U] ::
      ControlEscape
      `c` <ins>[no space here]</ins> ControlLetter
      `0` <ins>[no space here]</ins> [lookahead &lt;! DecimalDigit]
      HexEscapeSequence
      RegExpUnicodeEscapeSequence[?U]
      IdentityEscape[?U]

    ControlEscape :: one of
      `f` `n` `r` `t` `v`

    ControlLetter :: one of
      `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
      `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

    GroupSpecifier[U] ::
      [empty]
      `?` <ins>[no space here]</ins> GroupName[?U]

    GroupName[U] ::
      `&lt;` <ins>[no space here]</ins> RegExpIdentifierName[?U] <ins>[no space here]</ins> `&gt;`

    RegExpIdentifierName[U] ::
      RegExpIdentifierStart[?U]
      RegExpIdentifierName[?U] <ins>[no space here]</ins> RegExpIdentifierPart[?U]

    RegExpIdentifierStart[U] ::
      UnicodeIDStart
      `$`
      `_`
      `\` <ins>[no space here]</ins> RegExpUnicodeEscapeSequence[?U]

    RegExpIdentifierPart[U] ::
      UnicodeIDContinue
      `$`
      `\` <ins>[no space here]</ins> RegExpUnicodeEscapeSequence[?U]
      &lt;ZWNJ&gt;
      &lt;ZWJ&gt;

    RegExpUnicodeEscapeSequence[U] ::
      [+U] `u` LeadSurrogate `\u` TrailSurrogate
      [+U] `u` LeadSurrogate
      [+U] `u` TrailSurrogate
      [+U] `u` NonSurrogate
      [~U] `u` Hex4Digits
      [+U] `u{` CodePoint `}`
  </emu-grammar>
  <p>Each `\\u` |TrailSurrogate| for which the choice of associated `u` |LeadSurrogate| is ambiguous shall be associated with the nearest possible `u` |LeadSurrogate| that would otherwise have no corresponding `\\u` |TrailSurrogate|.</p>
  <emu-grammar type="definition">
    LeadSurrogate ::
      Hex4Digits [> but only if the SV of |Hex4Digits| is in the inclusive range 0xD800 to 0xDBFF]

    TrailSurrogate ::
      Hex4Digits [> but only if the SV of |Hex4Digits| is in the inclusive range 0xDC00 to 0xDFFF]

    NonSurrogate ::
      Hex4Digits [> but only if the SV of |Hex4Digits| is not in the inclusive range 0xD800 to 0xDFFF]

    IdentityEscape[U] ::
      [+U] SyntaxCharacter
      [+U] `/`
      [~U] SourceCharacter but not UnicodeIDContinue

    DecimalEscape ::
      NonZeroDigit DecimalDigits? [lookahead &lt;! DecimalDigit]

    CharacterClassEscape[U] ::
      `d`
      `D`
      `s`
      `S`
      `w`
      `W`
      [+U] `p{` UnicodePropertyValueExpression `}`
      [+U] `P{` UnicodePropertyValueExpression `}`

    UnicodePropertyValueExpression ::
      UnicodePropertyName `=` UnicodePropertyValue
      LoneUnicodePropertyNameOrValue

    UnicodePropertyName ::
      UnicodePropertyNameCharacters

    UnicodePropertyNameCharacters ::
      UnicodePropertyNameCharacter UnicodePropertyNameCharacters?

    UnicodePropertyValue ::
      UnicodePropertyValueCharacters

    LoneUnicodePropertyNameOrValue ::
      UnicodePropertyValueCharacters

    UnicodePropertyValueCharacters ::
      UnicodePropertyValueCharacter UnicodePropertyValueCharacters?

    UnicodePropertyValueCharacter ::
      UnicodePropertyNameCharacter
      `0`
      `1`
      `2`
      `3`
      `4`
      `5`
      `6`
      `7`
      `8`
      `9`

    UnicodePropertyNameCharacter ::
      ControlLetter
      `_`

    CharacterClass[U] ::
      `[` [lookahead &lt;! {`^`}] ClassRanges[?U] `]`
      `[` `^` ClassRanges[?U] `]`

    ClassRanges[U] ::
      [empty]
      NonemptyClassRanges[?U]

    NonemptyClassRanges[U] ::
      ClassAtom[?U]
      ClassAtom[?U] NonemptyClassRangesNoDash[?U]
      ClassAtom[?U] `-` ClassAtom[?U] ClassRanges[?U]

    NonemptyClassRangesNoDash[U] ::
      ClassAtom[?U]
      ClassAtomNoDash[?U] NonemptyClassRangesNoDash[?U]
      ClassAtomNoDash[?U] `-` ClassAtom[?U] ClassRanges[?U]

    ClassAtom[U] ::
      `-`
      ClassAtomNoDash[?U]

    ClassAtomNoDash[U] ::
      SourceCharacter but not one of `\` or `]` or `-`
      `\` ClassEscape[?U]

    ClassEscape[U] ::
      `b`
      [+U] `-`
      CharacterClassEscape[?U]
      CharacterEscape[?U]

    <ins class="block">
      RegExpWhitespaceOrCommentToken ::
        RegExpWhitespaceCharacter
        `#` SingleLineCommentChars
  
      RegExpWhitespaceOrComment ::
        RegExpWhitespaceOrCommentToken RegExpWhitespaceOrComment?
  
      RegExpWhitespaceCharacter ::
        &gt; any Unicode whitespace character
  
    </ins>
  </emu-grammar>
  <emu-note type="editor">Unmodified elements of this syntax can be removed from the proposal at the end of editing.</emu-note>
</emu-clause>
